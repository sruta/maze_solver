import { IMaze } from "../../src/interfaces/maze.interfaces";
import newService from "../../src/services/maze.service";
import {
  invalidMazeLayoutMock,
  mazeRepositoryMock,
  mazeSolverMock,
  validMazeLayoutMock,
  validMazeMock,
} from "./mocks";

describe("MazeService", () => {
  const repository = mazeRepositoryMock(validMazeMock);
  const solver = mazeSolverMock;
  const service = newService(repository, solver);

  describe("create()", () => {
    it("should return an IMaze based on the layout", () => {
      const result = service.create(validMazeLayoutMock);
      expect(repository.insert).toBeCalled();
      expect((result as IMaze).id).not.toBe("");
      expect((result as IMaze).layout.length).toBeGreaterThan(0);
    });

    it("should return an error if the layout is invalid at business level", () => {
      const result = service.create(invalidMazeLayoutMock);
      expect(result).toHaveProperty("message");
    });
  });

  describe("autogenerate()", () => {
    const result = service.autogenerate();
    it("should return an autogenerated IMaze", () => {
      expect(repository.insert).toBeCalled();
      expect(result.id).not.toBe("");
      expect(result.layout.length).toBeGreaterThan(0);
    });
  });

  describe("findById()", () => {
    service.findById(validMazeMock.id);
    it("should call respository.fetch()", () => {
      expect(repository.fetch).toHaveBeenCalledWith(validMazeMock.id);
    });
  });

  describe("solve()", () => {
    service.solve(validMazeMock.id);
    it("should call repository.fetch()", () => {
      expect(repository.fetch).toHaveBeenCalledWith(validMazeMock.id);
    });
    it("should return an Error if the maze DOESN'T EXISTS", () => {
      expect(service.solve(validMazeMock.id + "x")).toHaveProperty("message");
    });
    it("should call solver.solve()", () => {
      expect(solver).toHaveBeenCalledWith(validMazeMock);
    });
  });
});

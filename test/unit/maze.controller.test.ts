import newController from "../../src/controllers/maze.controller";
import {
  invalidMazeLayoutMock,
  mazeServiceMock,
  validMazeLayoutMock,
  validMazeLayoutSolutionMock,
  validMazeMock,
} from "./mocks";
import { getMockReq, getMockRes } from "@jest-mock/express";

describe("MazeController", () => {
  afterEach(() => jest.clearAllMocks());

  const service = mazeServiceMock(validMazeMock);
  const controller = newController(service);

  describe("create()", () => {
    const req = getMockReq();
    const { res, next } = getMockRes();

    it("should call service.create()", () => {
      req.body.layout = validMazeLayoutMock;
      controller.create(req, res, next);
      expect(service.create).toHaveBeenCalled();
      expect(res.status).toHaveBeenCalledWith(201);
      expect(res.send).toHaveBeenCalled();
    });

    it("should return 400 if body has errors", () => {
      req.body.layout = [];
      controller.create(req, res, next);
      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.send).toHaveBeenCalled();
    });

    it("should return 400 if service.create() returns errors", () => {
      req.body.layout = invalidMazeLayoutMock;
      controller.create(req, res, next);
      expect(service.create).toHaveBeenCalled();
      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.send).toHaveBeenCalled();
    });
  });

  describe("createAutogenerated()", () => {
    const req = getMockReq();
    const { res, next } = getMockRes();

    it("should call service.autogenerate()", () => {
      controller.createAutogenerated(req, res, next);
      expect(service.autogenerate).toHaveBeenCalled();
      expect(res.status).toHaveBeenCalledWith(201);
      expect(res.send).toHaveBeenCalled();
    });
  });

  describe("get()", () => {
    const req = getMockReq();
    const { res, next } = getMockRes();

    it("should call service.findById()", () => {
      req.params.id = validMazeMock.id;
      controller.get(req, res, next);
      expect(service.findById).toHaveBeenCalledWith(req.params.id);
    });

    it("should return 200 and the maze if its found", () => {
      req.params.id = validMazeMock.id;
      controller.get(req, res, next);
      expect(res.status).toHaveBeenCalledWith(200);
      expect(res.send).toHaveBeenCalledWith(validMazeMock);
    });

    it("should return 404 if the maze is not found", () => {
      req.params.id = validMazeMock.id + "x";
      controller.get(req, res, next);
      expect(res.status).toHaveBeenCalledWith(404);
      expect(res.send).toHaveBeenCalled();
    });
  });

  describe("solve()", () => {
    const req = getMockReq();
    const { res, next } = getMockRes();

    it("should call service.solve()", () => {
      req.params.id = validMazeMock.id;
      controller.solve(req, res, next);
      expect(service.solve).toHaveBeenCalledWith(req.params.id);
    });

    it("should return 200 and the layout if its solvable", () => {
      req.params.id = validMazeMock.id;
      controller.solve(req, res, next);
      expect(res.status).toHaveBeenCalledWith(200);
      expect(res.send).toHaveBeenCalledWith(validMazeLayoutSolutionMock);
    });

    it("should return 404 if the maze is not found for solving", () => {
      req.params.id = validMazeMock.id + "x";
      controller.solve(req, res, next);
      expect(res.status).toHaveBeenCalledWith(404);
      expect(res.send).toHaveBeenCalled();
    });
  });
});

import {
  GATE,
  IMaze,
  IMazeRepository,
  IMazeService,
  MazeLayout,
  MazeSolver,
} from "../interfaces/maze.interfaces";

const validateLayout = (layout: MazeLayout): string => {
  if (layout.length == 0) {
    return "layout length must be greater than 0";
  }

  let gates = 0;
  for (let i = 0; i < layout.length; i++) {
    if (layout[i].length != layout.length) {
      return "layout is not a square";
    }

    // GATES validation
    if (i == 0 || i == layout.length - 1) {
      for (let j = 0; j < layout.length; j++) {
        if (layout[i][j] == GATE) {
          gates++;
        }
      }
    } else {
      if (layout[i][0] == GATE) {
        gates++;
      }
      if (layout[i][layout.length - 1] == GATE) {
        gates++;
      }
    }
  }

  if (gates != 2) {
    return `layout haves ${gates} gates`;
  }

  return "";
};

const newService = (
  repository: IMazeRepository,
  solver: MazeSolver
): IMazeService => {
  return {
    create: (layout: MazeLayout): IMaze | Error => {
      const errors = validateLayout(layout);
      if (errors.length > 0) {
        return new Error(errors);
      }

      const maze = { id: "", layout };
      maze.id = repository.insert(maze);
      return maze;
    },

    // Creates the base layout.
    // Can be improved by sending the layout in the body of the request and then
    // validating the correctness or can be autogenerated following certain rules.
    autogenerate: (): IMaze => {
      const maze = {
        id: "",
        layout: [
          ["A", "B", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A"],
          ["A", "C", "A", "D", "D", "E", "A", "C", "C", "C", "D", "A"],
          ["A", "C", "C", "D", "A", "E", "A", "D", "A", "D", "A", "A"],
          ["A", "A", "A", "A", "A", "E", "D", "D", "A", "D", "E", "A"],
          ["A", "C", "C", "D", "D", "D", "A", "A", "A", "A", "E", "A"],
          ["A", "C", "A", "A", "A", "A", "A", "D", "D", "D", "E", "A"],
          ["A", "D", "D", "D", "E", "E", "A", "C", "A", "A", "A", "A"],
          ["A", "A", "A", "E", "A", "E", "A", "C", "C", "D", "D", "A"],
          ["A", "D", "E", "E", "A", "D", "A", "A", "A", "A", "A", "A"],
          ["A", "A", "D", "A", "A", "D", "A", "C", "D", "D", "A", "A"],
          ["A", "D", "D", "D", "A", "D", "C", "C", "A", "D", "E", "B"],
          ["A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A"],
        ],
      };
      maze.id = repository.insert(maze);
      return maze;
    },

    findById: (id: string): IMaze | Error => {
      return repository.fetch(id);
    },

    solve: (id: string): MazeLayout | Error => {
      const maze = repository.fetch(id);
      if (maze instanceof Error) {
        return maze;
      }

      return solver(maze);
    },
  };
};

export default newService;
